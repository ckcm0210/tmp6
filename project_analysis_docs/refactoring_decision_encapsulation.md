# 重構決策文檔：為何將函數封裝成類別是必要的？

本文檔旨在記錄在重構 `core/worksheet_tree.py` 過程中，關於將 `explode_dependencies_popup` 函數封裝成一個獨立類別的決策過程。

## 背景與問題

**使用者提問：**

> 封裝為類別 (Encapsulation) 呢啲動作應該比較大，係咪有必要一定要咁樣做？點解之前唔需要封裝做類別都可以進行到，而依家你就話要需要封裝做類別？我需要一個嚴謹嘅解釋。

這是一個非常深刻且關鍵的問題。從「讓程式能跑起來」的角度看，即使不封裝成類別，直接將整個 `explode_dependencies_popup` 函數搬到新檔案中，它**依然可以運作**。

然而，我們的目標不僅僅是「搬家」，而是要**徹底改善房屋的內部格局和管線系統**，以確保未來數年的擴展和維護都能輕鬆應對。這一步是從「能動的程式碼」邁向「高品質、易維護的工程化程式碼」的關鍵。

## 分析與解釋

### 問題所在：為什麼「僅作為一個巨大函數」是個隱患？

一個像「依賴關係爆炸」這樣複雜的彈出視窗，它自身就包含了很多**狀態 (State)** 和**行為 (Behavior)**。

*   **狀態 (State)**：例如「分析是否正在進行中 (`analysis_running`)」、「使用者選擇的顯示選項 (`show_full_address_var`)」、「樹狀圖中的數據 (`tree_data`)」、「進度條的當前值」等等。
*   **行為 (Behavior)**：例如「開始分析 (`start_analysis`)」、「刷新樹狀圖顯示 (`refresh_tree_display`)」、「處理雙擊事件 (`on_tree_double_click`)」、「生成圖表 (`handle_generate_graph`)」等等。

當這一切都存在於一個巨大的函數中時，會出現以下問題：

1.  **狀態管理的混亂 (State Management Hell)**：所有狀態都是透過一堆散落的局部變數來管理的。這非常脆弱，因為：
    *   **缺乏組織**：很難一眼看出哪些變數是屬於這個視窗的狀態。
    *   **傳遞困難**：當一個輔助函數（例如 `refresh_tree_display`）需要存取或修改某個狀態時，你必須將這個狀態作為參數一層一層地傳遞下去，導致函數簽名變得越來越長、越來越混亂。
    *   **生命週期問題**：所有狀態的生命週期都綁定在這次函數呼叫中。一旦視窗關閉，一切都消失了。如果未來想增加「暫停/恢復分析」或「保存視窗狀態」等功能，將會非常困難。

2.  **缺乏清晰的邊界 (Lack of Clear Boundary)**：一個獨立的函數沒有明確的「內」和「外」。
    *   **命名空間污染**：它內部的所有輔助函數（如 `populate_tree`, `show_summary`）要麼得定義在全域（污染 `ui/dependency_exploder_view.py` 的命名空間），要麼得全部嵌套在主函數內部，使得主函數更加臃腫不堪。
    *   **隱性依賴**：它依賴外部傳入的大量參數（`controller`, `workbook_path`...），形成了緊密的耦合。

### 解決方案：為什麼「封裝成類別」是嚴謹的做法？

將其封裝成一個 `DependencyExploderView` 類別，可以完美地解決上述所有問題：

1.  **結構化的狀態管理 (Structured State Management)**：
    *   類別天生就是用來捆綁「狀態」和「行為」的。所有相關的狀態變數都會變成類別的實例屬性（`self.analysis_running`, `self.tree_data`）。這提供了一個**單一、有組織的容器**來存放視窗的所有狀態。
    *   類別中的任何方法（行為）都可以透過 `self` 輕鬆地存取和修改任何狀態屬性，**無需再透過冗長的參數傳遞**。這使得新增功能變得極為簡單。

2.  **清晰的介面與邊界 (Clear Interface and Boundaries)**：
    *   類別本身就是一個清晰的邊界。外部程式碼（`worksheet_tree.py`）只需要知道如何創建這個類別的實例 (`DependencyExploderView(...)`)，這就是它的**公開介面 (Public Interface)**。
    *   所有內部的輔助函數都變成了類別的**私有方法 (Private Methods)**。它們被完美地「藏」在了類別內部，不會污染外部命名空間，也清楚地表明了「這些是內部實現細節，外部不應關心」。

3.  **提升可維護性與可複用性 (Improved Maintainability & Reusability)**：
    *   這個彈出視窗變成了一個**自給自足、可插拔的「元件」**。它自己管理自己的所有狀態和行為。
    *   當未來需要修改這個視窗的任何功能時，我們能百分之百確定，需要修改的程式碼**只會在這個類別檔案中**，極大地降低了心智負擔和引入新 Bug 的風險。

### 類比

如果我們只是把所有家具（程式碼）從一個大房間 (`worksheet_tree.py`) 搬到另一個空房間 (`dependency_exploder_view.py`)，那只是**換個地方亂而已**。

將其封裝成一個類別，就好比我們在新家裡，把所有屬於「廚房」的工具（變數、輔助函數）都放進一個叫「廚房」(`DependencyExploderView` 類別) 的房間裡，並給這個房間裝上一扇門 (`__init__` 方法)。外面的人（主程式）只需要知道如何使用這扇門，而不需要關心廚房裡面是如何運作的。這讓整個房子的佈局（專案架構）變得井然有序。

### 結論

這一步「封裝」並非畫蛇添足，而是為了達成您「容易維護、容易擴展」的最終目標所**必須採取的、最嚴謹的工程步驟**。這是從能運作的腳本到健壯軟體系統的躍升。
